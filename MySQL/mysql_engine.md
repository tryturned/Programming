在文件系统中，MySQL将每个数据库（也可以称之为schema）保存为数据目录下的一个子目录。创建表时，MySQL会在数据库子目录下创建一个和表同名的`.frm文件`保存表的定义。例如创建一个名为`MyTable` 的表，MySQL会在`MyTable.frm `文件中保存该表的定义。  

可以使用 `SHOW TABLE STATUS ` 命令显示表的相关信息。例如:  
```
mysql> show table status like  'autoincre_demo' \G;
*************************** 1. row ***************************
           Name: autoincre_demo
         Engine: MyISAM
        Version: 10
     Row_format: Dynamic
           Rows: 8
 Avg_row_length: 20
    Data_length: 240
Max_data_length: 281474976710655
   Index_length: 2048
      Data_free: 80
 Auto_increment: 8
    Create_time: 2020-10-18 16:56:40
    Update_time: 2020-11-10 14:59:11
     Check_time: NULL
      Collation: latin1_swedish_ci
       Checksum: NULL
 Create_options: 
        Comment: 
1 row in set (0.00 sec)
```
[toc]
# 1. InnoDB存储引擎
InnoDB是MySQL的默认事务型引擎，也是最重要、使用最广泛的存储引擎。它被设计用来处理大量的短期（short-lived）事务，短期事务大部分情况是正常提交的，很少会被回滚。  

# 2. MyISAM存储引擎

MyISAM提供了大量的特性，包括全文索引、压缩、空间函数（GIS）等，但MyISAM不支持事务和行级锁，而且有一个毫无疑问的缺陷就是崩溃后无法安全恢复。尽管MyISAM引擎不支持事务、不支持崩溃后的安全恢复，但它绝不是一无是处的。对于只读的数据，或者表比较小、可以忍受修复（repair）操作，则依然可以继续使用MyISAM（但请不要默认使用MyISAM，而是应当默认使用InnoDB）。

## 2.1 MyISAM特性
**加锁与并发**：  
MyISAM对整张表加锁，而不是针对行。读取时会对需要读到的所有表加共享锁，写入时则对表加排他锁。但是在表有读取查询的同时，也可以往表中插入新的记录（这被称为并发插入，CONCURRENT INSERT）。  

**修复**：
对于MyISAM表，MySQL可以手工或者自动执行检查和修复操作，但这里说的修复和事务恢复以及崩溃恢复是不同的概念。执行表的修复可能导致一些数据丢失，而且修复操作是非常慢的。可以
通过`CHECK TABLE mytable `检查表的错误，如果有错误可以通过执行`REPAIR TABLE mytable` 进行修复。另外，如果MySQL服务器已经关闭，也可以通过`myisamchk`命令行工具进行检查和修复操作。  

**索引特性**:  
对于MyISAM表，即使是BLOB和TEXT等长字段，也可以基于其前500个字符创建索引。MyISAM也支持全文索引，这是一种基于分词创建的索引，可以支持复杂的查询。  

**延迟更新索引键（Delayed Key Write）**:  
创建MyISAM表的时候，如果指定了`DELAY_KEY_WRITE`选项，在每次修改执行完成时，不会立刻将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区`（in-memory key buffer）`，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入到磁盘。这种
方式可以极大地提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。延迟更新索引键的特性，可以在全局设置，也可以为单个表设置。  

## 2.2 MyISAM压缩表
如果表在创建并导入数据以后，不会再进行修改操作，那么这样的表或许适合采用MyISAM压缩表。**压缩时表中的记录是独立压缩的**，所以读取单行的时候不需要去解压整个表（甚至也不解压行所在的整个页面）。这样，对大多数应用场景，读取压缩表数据时的解压带来的开销影响并不大，而减少I/O带来的好处则要大得多。

可以使用`myisampack `对MyISAM表进行压缩（也叫打包pack）。压缩表是不能进行修改的（除非先将表解除压缩，修改数据，然后再次压缩）。压缩表可以极大地减少磁盘空间占用，因此也可以减少磁盘`I/O`，从而提升查询性能。压缩表也支持索引，但索引也是只读的。

## 2.3 MyISAM性能
MyISAM引擎设计简单，数据以紧密格式存储，所以在某些场景下的性能很好。   

但MyISAM最典型的性能问题还是表锁的问题，如果你发现所有的查询都长期处于“Locked”状态，那么毫无疑问表锁就是罪魁祸首。  

# 3. 选择合适的引擎
**“除非需要用到某些InnoDB不具备的特性，并且没有其他办法可以替代，否则都应该优先选择InnoDB引擎”**  

如果不需要用到InnoDB的特性，同时其他引擎的特性能够更好地满足需求，也可以考虑一下其他存储引擎。举个例子，**如果不在乎可扩展能力和并发能力，也不在乎崩溃后的数据丢失问题，却对InnoDB的空间占用过多比较敏感，这种场合下选择MyISAM就比较合适。**  

应用不同的存储引擎，请考虑以下几个因素：  

**事务**  
如果应用需要事务支持，那么`InnoDB`是目前最稳定并且经过验证的选择。如果不需要事务，并且主要是SELECT和INSERT 操作，那么MyISAM是不错的选择。一般日志型的应用比
较符合这一特性。

**备份**  
备份的需求也会影响存储引擎的选择。如果可以定期地关闭服务器来执行备份，那么备份的因素可以忽略。反之，如果需要在线热备份，那么选择InnoDB就是基本的要求。  
>热备份是在数据库运行的情况下，备份数据库操作的sql语句，当数据库发生问题时，可以重新执行一遍备份的sql语句。


**崩溃恢复**  
数据量比较大的时候，系统崩溃后如何快速地恢复是一个需要考虑的问题。相对而言，MyISAM崩溃后发生损坏的概率比InnoDB要高很多，而且恢复速度也要慢。因此，即使不需要事务支持，很
多人也选择InnoDB引擎，这是一个非常重要的因素。  

**特有的特性**  
如果一个存储引擎拥有一些关键的特性，同时却又缺乏一些必要的特性，那么有时候不得不做折中的考虑，或者在架构设计上做一些取舍。某些存储引擎无法直接支持的特性，有时候通过变通也可以满足需求。  

# 4. 转换表的引擎
## 4.1 ALTER TABLE
将表从一个引擎修改为另一个引擎最简单的办法是使用`ALTER TABLE` 语句。下面的语句将mytable 的引擎修改为InnoDB：
```
mysql> ALTER TABLE mytable ENGINE=InnoDB;
```

**优点：**  
适用任何存储引擎

**缺点：**  
需要执行很长时间。MySQL会按行将数据从原表复制到一张新的表中，在复制期间可能会消耗系统所有的I/O能力，同时原表上会加上读锁。所以，在繁忙的表上执行此操作要特别小心。一个替代方案是采用接下来将讨论的导出与导入的方法，手工进行表的复制。  

## 4.2 导出与导入
为了更好地控制转换的过程，可以使用`mysqldump `工具将数据导出到文件，然后修改文件中`CREATE TABLE` 语句的存储引擎选项，注意同时修改表名，因为同一个数据库中不能存在相同的表名，即使它们使用的是不同的存储引擎。同时要注意`mysqldump` 默认会自动在`CREATE TABLE` 语句前加上`DROP TABLE` 语句，不注意这一点可能会导致数据丢失。  

## 4.3 创建与查询（CREATE和SELECT）
该方法综合了第一种方法的高效和第二种方法的安全。不需要导出整个表的数据，而是先创建一个新的存储引擎的表，然后利用INSERT…SELECT 语法来导数据：  
```
mysql> CREATE TABLE innodb_table LIKE myisam_table;

mysql> ALTER TABLE innodb_table ENGINE=InnoDB;

mysql> INSERT INTO innodb_table SELECT * FROM myisam_table;
```

数据量不大的话，这样做工作得很好。如果数据量很大，则可以考虑做分批处理，针对每一段数据执行事务提交操作，以避免大事务产生过多的undo。  

假设有主键字段id ，重复运行以下语句（最小值x 和最大值y进行相应的替换）将数据导入到新表：  
```
mysql> START TRANSACTION;

mysql> INSERT INTO innodb_table SELECT * FROM myisam_table WHERE id BETWEEN x AND y;

COMMIT;
```